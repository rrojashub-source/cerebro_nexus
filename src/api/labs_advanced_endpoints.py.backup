"""
LABS 029-050: Advanced Cognitive Systems - API Endpoints
Integration for Creativity, Learning, Plasticity, and Homeostasis LABS

To integrate into main.py:
1. Import this module: from labs_advanced_endpoints import router as labs_advanced_router
2. Include router: app.include_router(labs_advanced_router)
"""

from fastapi import APIRouter, HTTPException, status
from pydantic import BaseModel, Field
from typing import List, Dict, Any, Optional
from datetime import datetime

# LAB_028: Emotional Intelligence (prerequisite for advanced LABs)
from emotional_intelligence import EmotionalIntelligenceSystem

# FASE 5: Creativity & Insight (LABS 029-033)
from divergent_thinking import DivergentThinkingSystem, Idea
from conceptual_blending import ConceptualBlendingSystem, ConceptualSpace
from insight_aha import InsightAhaSystem, Problem
from analogical_reasoning import AnalogicalReasoningSystem, Structure
from metaphor_generation import MetaphorGenerationSystem

# FASE 6: Advanced Learning (LABS 034-038)
from transfer_learning import TransferLearningSystem, Knowledge, LearningContext
from reward_prediction import RewardPredictionSystem
from meta_learning import MetaLearningSystem, Task as MetaTask
from curiosity_drive import CuriosityDriveSystem
from intrinsic_motivation import IntrinsicMotivationSystem

# FASE 7: Neuroplasticity (LABS 039-043)
from ltp_ltd import LTPLTDSystem
from hebbian_learning import HebbianLearningSystem
from synaptic_pruning_neurogenesis import SynapticPruningNeurogenesisSystem

# FASE 8: Homeostasis (LABS 044-050)
from homeostasis_systems import HomeostasisSystem

# ============================================
# Router
# ============================================
router = APIRouter(prefix="/labs/advanced", tags=["Advanced LABS 029-050"])

# ============================================
# Global System Instances
# ============================================

# LAB_028: Emotional Intelligence
emotional_intelligence = EmotionalIntelligenceSystem()

# FASE 5: Creativity
divergent_thinking = DivergentThinkingSystem()
conceptual_blending = ConceptualBlendingSystem()
insight_system = InsightAhaSystem()
analogy_system = AnalogicalReasoningSystem()
metaphor_system = MetaphorGenerationSystem()

# FASE 6: Learning
transfer_learning = TransferLearningSystem()
reward_prediction = RewardPredictionSystem()
meta_learning = MetaLearningSystem()
curiosity_drive = CuriosityDriveSystem()
intrinsic_motivation = IntrinsicMotivationSystem()

# FASE 7: Plasticity
ltp_ltd = LTPLTDSystem()
hebbian_learning = HebbianLearningSystem()
synaptic_pruning = SynapticPruningNeurogenesisSystem()

# FASE 8: Homeostasis
homeostasis = HomeostasisSystem()

# ============================================
# Pydantic Models
# ============================================

# LAB_028: Emotional Intelligence (prerequisite)
class EmotionRecognitionRequest(BaseModel):
    source: str = Field(..., description="Source type: 'facial', 'vocal', 'contextual', 'self'")
    cues: List[str] = Field(..., description="List of emotional cues (e.g., ['smiling', 'relaxed_posture'])")
    person_id: Optional[str] = Field(None, description="Optional person identifier")
    context: Optional[str] = Field(None, description="Optional situational context")

class EmotionRecognitionResponse(BaseModel):
    success: bool
    emotion: str
    intensity: float
    confidence: float
    source: str
    person_id: Optional[str] = None
    timestamp: datetime

# LAB_029: Divergent Thinking
class DivergentThinkingRequest(BaseModel):
    object_name: str = Field(..., description="Object for alternative uses generation")
    num_ideas: int = Field(default=10, ge=1, le=50)

class DivergentThinkingResponse(BaseModel):
    success: bool
    object_name: str
    ideas: List[Dict[str, Any]]
    fluency: float
    flexibility: int
    avg_originality: float
    timestamp: datetime

# LAB_030: Conceptual Blending
class ConceptualBlendingRequest(BaseModel):
    concept_1: str = Field(..., description="First concept (e.g., 'house')")
    concept_2: str = Field(..., description="Second concept (e.g., 'boat')")

class ConceptualBlendingResponse(BaseModel):
    success: bool
    blend_name: str
    emergent_properties: List[str]
    novelty_score: float
    all_properties: List[str]
    timestamp: datetime

# LAB_031: Insight
class InsightRequest(BaseModel):
    problem_type: str = Field(..., description="nine_dot, two_string, or candle")
    max_attempts: int = Field(default=10, ge=1, le=50)

class InsightResponse(BaseModel):
    success: bool
    problem_type: str
    insight_achieved: bool
    insight_type: Optional[str] = None
    restructuring: Optional[str] = None
    aha_intensity: Optional[float] = None
    attempts_before_insight: int
    timestamp: datetime

# LAB_032: Analogical Reasoning
class AnalogyRequest(BaseModel):
    source_domain: str = Field(..., description="Source domain name (e.g., 'solar_system')")
    target_domain: str = Field(..., description="Target domain name (e.g., 'atom')")

class AnalogyResponse(BaseModel):
    success: bool
    entity_mappings: Dict[str, str]
    relation_mappings: List[Dict[str, Any]]
    structural_similarity: float
    domain_distance: float
    transfer_likelihood: str
    timestamp: datetime

# LAB_033: Metaphor
class MetaphorGenerationRequest(BaseModel):
    target_concept: str = Field(..., description="Target concept (e.g., 'love', 'life', 'argument')")
    source_domain: str = Field(..., description="Source domain: journey, war, building, container, machine, organism, light, darkness, time, space")

class MetaphorGenerationResponse(BaseModel):
    success: bool
    target_concept: str
    source_domain: str
    metaphor: str
    mappings: Dict[str, str]
    novelty_score: float
    timestamp: datetime

# LAB_034: Transfer Learning
class TransferLearningRequest(BaseModel):
    knowledge_id: str = Field(..., description="Unique knowledge identifier")
    knowledge_domain: str = Field(..., description="Source domain (e.g., 'mathematics', 'physics', 'chess')")
    knowledge_content: str = Field(..., description="Knowledge content")
    abstraction_level: int = Field(default=0, ge=0, le=5, description="Abstraction level (0=concrete, 5=very abstract)")
    target_domain: str = Field(..., description="Target domain for transfer")

class TransferLearningResponse(BaseModel):
    success: bool
    transfer_successful: bool
    success_probability: float
    domain_distance: float
    transfer_type: str
    timestamp: datetime

# LAB_035: Reward Prediction
class RewardPredictionRequest(BaseModel):
    state: str = Field(..., description="Current state ID")
    action: str = Field(..., description="Action taken")
    next_state: str = Field(..., description="Next state ID")
    reward: float = Field(..., description="Reward received")
    done: bool = Field(default=False, description="Episode terminated")

class RewardPredictionResponse(BaseModel):
    success: bool
    td_error: float
    predicted_value: float
    uncertainty: float
    update_count: int
    timestamp: datetime

# LAB_036: Meta-Learning
class MetaLearningRequest(BaseModel):
    task_id: str = Field(..., description="Task identifier")
    domain: str = Field(..., description="Task domain (vision, audio, etc.)")
    difficulty: float = Field(default=0.5, ge=0.0, le=1.0, description="Task difficulty")
    trials: int = Field(default=10, ge=1, le=100, description="Number of learning trials")

class MetaLearningResponse(BaseModel):
    success: bool
    task_id: str
    learning_rate_used: float
    performance: float
    trials: int
    timestamp: datetime

# LAB_037: Curiosity Drive
class CuriosityRequest(BaseModel):
    obs_id: str = Field(..., description="Observation identifier")
    features: Dict[str, float] = Field(..., description="Feature values for the observation")

class CuriosityResponse(BaseModel):
    success: bool
    obs_id: str
    curiosity_bonus: float
    novelty: float
    prediction_error: float
    timestamp: datetime

# LAB_038: Intrinsic Motivation
class IntrinsicMotivationRequest(BaseModel):
    action_type: str = Field(..., description="Type of action: 'autonomy', 'competence', or 'relatedness'")
    value: float = Field(..., ge=0.0, le=1.0, description="Value for the action (0-1)")
    success: bool = Field(default=True, description="Whether action was successful (for competence)")
    challenge: float = Field(default=0.5, ge=0.0, le=1.0, description="Challenge level (for competence)")

class IntrinsicMotivationResponse(BaseModel):
    success: bool
    action_type: str
    autonomy: float
    competence: float
    relatedness: float
    overall_motivation: float
    timestamp: datetime

# LAB_039-043: Plasticity
class SynapseStimulationRequest(BaseModel):
    synapse_id: str
    intensity: float = Field(ge=0.0, le=1.0)

class SynapseStimulationResponse(BaseModel):
    success: bool
    synapse_id: str
    result: str  # "LTP", "LTD", or "No change"
    new_strength: float
    timestamp: datetime

class HebbianActivationRequest(BaseModel):
    neuron_ids: List[str] = Field(..., description="Neurons to co-activate")

class HebbianActivationResponse(BaseModel):
    success: bool
    activated_neurons: List[str]
    connections_formed: int
    avg_weight: float
    timestamp: datetime

# LAB_044-050: Homeostasis
class HomeostasisUpdateRequest(BaseModel):
    dt: float = Field(default=1.0, ge=0.1, le=24.0, description="Time delta in hours")

class HomeostasisUpdateResponse(BaseModel):
    success: bool
    circadian_phase: float
    energy_level: float
    stress_level: float
    allostatic_load: float
    sleep_pressure: float
    recovery_rate: float
    timestamp: datetime

class StressorRequest(BaseModel):
    intensity: float = Field(ge=0.0, le=1.0)

class SleepRequest(BaseModel):
    duration: float = Field(ge=0.1, le=12.0, description="Sleep duration in hours")

# ============================================
# LAB_028: Emotional Intelligence (prerequisite)
# ============================================

@router.post("/emotional-intelligence/recognize", response_model=EmotionRecognitionResponse, tags=["LAB_028"])
async def recognize_emotion_endpoint(request: EmotionRecognitionRequest):
    """
    LAB_028: Recognize emotion from cues (Mayer & Salovey 1997)

    Implements:
    - Emotion recognition from facial, vocal, contextual, or self cues
    - Confidence scoring based on cue quality
    - Supports multiple emotion sources

    Integration with:
    - LAB_001 (Emotional Salience) for importance
    - LAB_024 (Empathy) for emotional resonance
    """
    try:
        # Call emotional intelligence system
        result = emotional_intelligence.recognize_emotion(
            source=request.source,
            cues=request.cues,
            person_id=request.person_id,
            context=request.context
        )

        return EmotionRecognitionResponse(
            success=True,
            emotion=result.emotion.value,
            intensity=result.intensity,
            confidence=result.confidence,
            source=result.source,
            person_id=result.person_id,
            timestamp=datetime.fromtimestamp(result.timestamp)
        )

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail=f"Emotion recognition failed: {str(e)}"
        )

# ============================================
# FASE 5: Creativity & Insight Endpoints
# ============================================

@router.post("/divergent-thinking", response_model=DivergentThinkingResponse, tags=["LAB_029"])
async def generate_alternative_uses(request: DivergentThinkingRequest):
    """
    LAB_029: Generate alternative uses for an object (Guilford's test)

    Measures:
    - Fluency (number of ideas)
    - Flexibility (number of categories)
    - Originality (statistical rarity)
    """
    try:
        # Generate ideas
        ideas = divergent_thinking.generator.generate_uses(
            request.object_name,
            request.num_ideas
        )

        # Calculate metrics
        fluency_result = divergent_thinking.fluency.compute_fluency(ideas, duration=60.0)
        flexibility_result = divergent_thinking.flexibility.compute_flexibility(ideas)
        originality_scores = [divergent_thinking.originality.compute_originality(idea)
                             for idea in ideas]

        return DivergentThinkingResponse(
            success=True,
            object_name=request.object_name,
            ideas=[{
                "content": idea.content,
                "category": idea.category,
                "originality": idea.originality_score
            } for idea in ideas],
            fluency=fluency_result["ideas_per_minute"],
            flexibility=flexibility_result["num_categories"],
            avg_originality=sum(originality_scores) / len(originality_scores) if originality_scores else 0.0,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Divergent thinking failed: {str(e)}"
        )


@router.post("/conceptual-blending", response_model=ConceptualBlendingResponse, tags=["LAB_030"])
async def create_conceptual_blend(request: ConceptualBlendingRequest):
    """
    LAB_030: Create conceptual blend from two concepts

    Fauconnier & Turner (2002) blending theory
    Example: concept_1="house", concept_2="boat" → houseboat (floating dwelling)
    """
    try:
        # Create blend using the system's API
        blend = conceptual_blending.create_blend(
            concept_1=request.concept_1,
            concept_2=request.concept_2
        )

        # Extract all properties from blended space
        all_properties = []
        for concept, props in blend.blended.properties.items():
            all_properties.extend(list(props))

        return ConceptualBlendingResponse(
            success=True,
            blend_name=blend.blend_id,
            emergent_properties=list(blend.emergent_properties),
            novelty_score=blend.novelty_score,
            all_properties=all_properties,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Conceptual blending failed: {str(e)}"
        )


@router.post("/insight", response_model=InsightResponse, tags=["LAB_031"])
async def generate_insight(request: InsightRequest):
    """
    LAB_031: Generate insight for classic insight problems

    Problems:
    - nine_dot: 9-dot problem (think outside the box)
    - two_string: Two-string problem (Maier, 1931)
    - candle: Candle problem (Duncker, 1945)
    """
    try:
        # Define classic insight problems
        problem_definitions = {
            "nine_dot": {
                "description": "Connect 9 dots in 3x3 grid with 4 straight lines without lifting pen",
                "constraints": {"pen_continuous", "lines_straight"}
            },
            "two_string": {
                "description": "Tie two strings hanging from ceiling, but cannot reach both at once",
                "constraints": {"distance_too_far", "strings_fixed"}
            },
            "candle": {
                "description": "Attach candle to wall using only box of tacks",
                "constraints": {"no_damage_wall", "candle_must_burn"}
            }
        }

        if request.problem_type not in problem_definitions:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Unknown problem type: {request.problem_type}. Valid: nine_dot, two_string, candle"
            )

        # Register problem if not exists
        if request.problem_type not in insight_system.problems:
            problem_def = problem_definitions[request.problem_type]
            insight_system.register_problem(
                problem_id=request.problem_type,
                description=problem_def["description"],
                constraints=problem_def["constraints"]
            )

        # Solve using full insight protocol
        history = insight_system.solve_with_insight_protocol(
            problem_id=request.problem_type,
            max_attempts=request.max_attempts
        )

        # Extract insight moment if occurred
        insight_moment = history.get("insight")

        # Map restructuring from old → new representation
        restructuring = None
        if insight_moment:
            restructuring = f"{insight_moment.old_representation} → {insight_moment.new_representation}"

        return InsightResponse(
            success=True,
            problem_type=request.problem_type,
            insight_achieved=history["insight_occurred"],
            insight_type=insight_moment.insight_type.value if insight_moment else None,
            restructuring=restructuring,
            aha_intensity=insight_moment.aha_intensity if insight_moment else None,
            attempts_before_insight=len(history["attempts"]),
            timestamp=datetime.now()
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Insight generation failed: {str(e)}"
        )


@router.post("/analogy", response_model=AnalogyResponse, tags=["LAB_032"])
async def create_analogy_endpoint(request: AnalogyRequest):
    """
    LAB_032: Create structural analogy between domains

    Gentner (1983) structure-mapping theory
    Example: source="solar_system", target="atom" → (sun→nucleus, planets→electrons)
    """
    try:
        # Create analogy using system's API
        mapping = analogy_system.create_analogy(
            source_name=request.source_domain,
            target_name=request.target_domain
        )

        # Evaluate quality
        quality = analogy_system.evaluate_mapping_quality(mapping)

        # Determine transfer type based on similarity
        transfer_type = "near" if mapping.surface_similarity > 0.5 else "far"

        return AnalogyResponse(
            success=True,
            entity_mappings=mapping.entity_mappings,
            relation_mappings=[
                {"source": r[0].relation_type.value, "target": r[1].relation_type.value}
                for r in mapping.relation_mappings
            ],
            structural_similarity=mapping.structural_similarity,
            domain_distance=1.0 - mapping.surface_similarity,  # Inverse of surface sim
            transfer_likelihood=transfer_type,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Analogy creation failed: {str(e)}"
        )


@router.post("/metaphor", response_model=MetaphorGenerationResponse, tags=["LAB_033"])
async def generate_metaphor_endpoint(request: MetaphorGenerationRequest):
    """
    LAB_033: Generate novel metaphor

    Lakoff & Johnson (1980) conceptual metaphor theory
    Example: target="love", source="journey" → "Our relationship is at a crossroads"
    """
    try:
        from metaphor_generation import Domain

        # Convert source_domain string to Domain enum
        try:
            source_domain_enum = Domain[request.source_domain.upper()]
        except KeyError:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid source domain: {request.source_domain}. Valid: {[d.value for d in Domain]}"
            )

        # Generate metaphor using system's API
        generation = metaphor_system.generate_novel_metaphor(
            target_concept=request.target_concept,
            source_domain=source_domain_enum
        )

        return MetaphorGenerationResponse(
            success=True,
            target_concept=request.target_concept,
            source_domain=request.source_domain,
            metaphor=generation.generated_expression,
            mappings={},  # MetaphorGeneration doesn't have mappings field
            novelty_score=generation.novelty_score,
            timestamp=datetime.now()
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Metaphor generation failed: {str(e)}"
        )


# ============================================
# FASE 6: Advanced Learning Endpoints
# ============================================

@router.post("/transfer-learning", response_model=TransferLearningResponse, tags=["LAB_034"])
async def transfer_knowledge_endpoint(request: TransferLearningRequest):
    """
    LAB_034: Transfer knowledge across domains

    Thorndike & Woodworth (1901) transfer of training
    Near transfer: similar domains (high success)
    Far transfer: dissimilar domains (harder, abstract knowledge transfers better)
    """
    try:
        # Acquire knowledge using system method
        knowledge = transfer_learning.acquire_knowledge(
            knowledge_id=request.knowledge_id,
            domain=request.knowledge_domain,
            content=request.knowledge_content,
            abstraction_level=request.abstraction_level
        )

        # Create minimal target context
        target_context = LearningContext(
            context_id=f"context_{request.target_domain}",
            domain=request.target_domain,
            features=set(),  # Minimal context
            difficulty=0.5
        )

        # Transfer knowledge using high-level API
        transfer_attempt = transfer_learning.transfer_knowledge(
            knowledge_id=request.knowledge_id,
            target_domain=request.target_domain,
            target_context=target_context
        )

        # Determine if transfer was successful (threshold at 0.5)
        transfer_successful = transfer_attempt.success_rate >= 0.5

        return TransferLearningResponse(
            success=True,
            transfer_successful=transfer_successful,
            success_probability=transfer_attempt.success_rate,
            domain_distance=transfer_attempt.transfer_distance,
            transfer_type=transfer_attempt.transfer_type.value,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Transfer learning failed: {str(e)}"
        )


@router.post("/reward-prediction", response_model=RewardPredictionResponse, tags=["LAB_035"])
async def learn_reward_prediction(request: RewardPredictionRequest):
    """
    LAB_035: Learn from transition and predict reward

    Temporal-difference learning (Sutton & Barto, 2018)
    Model-free and model-based reward prediction
    """
    try:
        # Learn from transition using high-level API
        td_error = reward_prediction.learn_from_transition(
            state=request.state,
            action=request.action,
            next_state=request.next_state,
            reward=request.reward,
            done=request.done
        )

        # Predict value of current state
        value_estimate = reward_prediction.predict_value(request.state)

        return RewardPredictionResponse(
            success=True,
            td_error=td_error,
            predicted_value=value_estimate.value,
            uncertainty=value_estimate.uncertainty,
            update_count=value_estimate.update_count,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Reward prediction failed: {str(e)}"
        )


@router.get("/reward-prediction/stats", tags=["LAB_035"])
async def get_reward_prediction_stats():
    """
    LAB_035: Get reward prediction statistics

    Combines model-free (TD learning) and model-based (forward model) RL
    """
    try:
        stats = reward_prediction.get_statistics()

        return {
            "success": True,
            "mode": stats.get("mode"),
            "states_visited": stats.get("states_visited"),
            "total_transitions": stats.get("total_transitions"),
            "avg_value": stats.get("avg_value"),
            "model_based_transitions": stats.get("model_based_transitions"),
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get stats: {str(e)}"
        )


@router.post("/meta-learning", response_model=MetaLearningResponse, tags=["LAB_036"])
async def learn_task_endpoint(request: MetaLearningRequest):
    """
    LAB_036: Meta-Learning - Learning to Learn

    Harlow (1949) learning sets - adapts learning rate based on task similarity
    MAML algorithm principles - rapid acquisition from experience
    """
    try:
        # Create task object
        task = MetaTask(
            task_id=request.task_id,
            domain=request.domain,
            difficulty=request.difficulty
        )

        # Learn task with adapted learning rate (high-level API)
        experience = meta_learning.learn_task(task, trials=request.trials)

        return MetaLearningResponse(
            success=True,
            task_id=experience.task_id,
            learning_rate_used=experience.learning_rate_used,
            performance=experience.performance,
            trials=experience.trials,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Meta-learning failed: {str(e)}"
        )


@router.post("/curiosity", response_model=CuriosityResponse, tags=["LAB_037"])
async def generate_curiosity_endpoint(request: CuriosityRequest):
    """
    LAB_037: Curiosity Drive - Generate curiosity bonus for observation

    Berlyne (1960) curiosity theory + Schmidhuber (1991) curiosity-driven learning
    Combines novelty (inverse familiarity) and prediction error to generate intrinsic reward
    """
    try:
        # Generate curiosity bonus (high-level API)
        curiosity_bonus = curiosity_drive.generate_curiosity_bonus(
            obs_id=request.obs_id,
            features=request.features
        )

        # Get the last observation to access novelty and prediction_error
        last_obs = curiosity_drive.observations[-1]

        return CuriosityResponse(
            success=True,
            obs_id=last_obs.obs_id,
            curiosity_bonus=curiosity_bonus,
            novelty=last_obs.novelty,
            prediction_error=last_obs.prediction_error,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Curiosity generation failed: {str(e)}"
        )


@router.get("/curiosity/stats", tags=["LAB_037"])
async def get_curiosity_stats():
    """
    LAB_037: Get curiosity drive statistics

    Schmidhuber (1991) curiosity-driven learning
    """
    try:
        stats = curiosity_drive.get_statistics()

        return {
            "success": True,
            **stats,
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get stats: {str(e)}"
        )


@router.post("/intrinsic-motivation", response_model=IntrinsicMotivationResponse, tags=["LAB_038"])
async def update_motivation_endpoint(request: IntrinsicMotivationRequest):
    """
    LAB_038: Intrinsic Motivation - Update motivation state

    Deci & Ryan (2000) Self-Determination Theory (SDT)
    Three basic psychological needs: Autonomy, Competence, Relatedness
    """
    try:
        # Update based on action type (high-level API)
        if request.action_type == "autonomy":
            intrinsic_motivation.update_autonomy(choice_freedom=request.value)
        elif request.action_type == "competence":
            intrinsic_motivation.update_competence(
                success=request.success,
                challenge=request.challenge
            )
        elif request.action_type == "relatedness":
            intrinsic_motivation.update_relatedness(social_connection=request.value)
        else:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=f"Invalid action_type: {request.action_type}. Must be 'autonomy', 'competence', or 'relatedness'"
            )

        # Get updated state
        state = intrinsic_motivation.get_motivation_state()

        return IntrinsicMotivationResponse(
            success=True,
            action_type=request.action_type,
            autonomy=state.autonomy,
            competence=state.competence,
            relatedness=state.relatedness,
            overall_motivation=state.overall,
            timestamp=datetime.now()
        )

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Motivation update failed: {str(e)}"
        )


@router.get("/intrinsic-motivation/stats", tags=["LAB_038"])
async def get_intrinsic_motivation_stats():
    """
    LAB_038: Get intrinsic motivation statistics

    Deci & Ryan (2000) Self-Determination Theory
    - Autonomy
    - Competence
    - Relatedness
    """
    try:
        state = intrinsic_motivation.get_motivation_state()

        return {
            "success": True,
            "autonomy": state.autonomy,
            "competence": state.competence,
            "relatedness": state.relatedness,
            "overall_motivation": state.overall,
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get stats: {str(e)}"
        )


# ============================================
# LAB_039-040: LTP & LTD (Neuroplasticity)
# ============================================


@router.post("/ltp-ltd", response_model=SynapseStimulationResponse, tags=["LAB_039", "LAB_040"])
async def stimulate_synapse(request: SynapseStimulationRequest):
    """
    LAB_039-040: Long-Term Potentiation & Depression

    Bliss & Lømo (1973) LTP discovery, Bear & Malenka (1994) mechanisms
    Synaptic strengthening (LTP) or weakening (LTD) based on stimulation intensity

    - intensity >= 0.7 → LTP (strengthen synapse +0.1)
    - intensity <= 0.3 → LTD (weaken synapse -0.1)
    - 0.3 < intensity < 0.7 → No change
    """
    try:
        # Get synapse strength before stimulation (if exists)
        synapse = ltp_ltd.synapses.get(request.synapse_id)
        strength_before = synapse.strength if synapse else 0.5

        # Stimulate synapse (high-level API)
        result = ltp_ltd.stimulate(request.synapse_id, request.intensity)

        # Get updated synapse
        synapse = ltp_ltd.synapses[request.synapse_id]

        return SynapseStimulationResponse(
            success=True,
            synapse_id=request.synapse_id,
            result=result,
            new_strength=synapse.strength,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Synapse stimulation failed: {str(e)}"
        )


# ============================================
# FASE 7: Neuroplasticity Endpoints
# ============================================

@router.post("/synapse/stimulate", response_model=SynapseStimulationResponse, tags=["LAB_039-040"])
async def stimulate_synapse(request: SynapseStimulationRequest):
    """
    LAB_039/040: Stimulate synapse (trigger LTP or LTD)

    Bliss & Lømo (1973) LTP, Bear & Malenka (1994) LTD
    - High intensity (≥0.7): LTP (strengthening)
    - Low intensity (≤0.3): LTD (weakening)
    """
    try:
        result = ltp_ltd.stimulate(request.synapse_id, request.intensity)
        synapse = ltp_ltd.synapses.get(request.synapse_id)

        return SynapseStimulationResponse(
            success=True,
            synapse_id=request.synapse_id,
            result=result,
            new_strength=synapse.strength if synapse else 0.5,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Synapse stimulation failed: {str(e)}"
        )


@router.post("/hebbian/activate", response_model=HebbianActivationResponse, tags=["LAB_041"])
async def activate_neurons_hebbian(request: HebbianActivationRequest):
    """
    LAB_041: Co-activate neurons (Hebbian learning)

    Hebb (1949): "Cells that fire together wire together"
    Creates connections between co-active neurons
    """
    try:
        import time

        # Activate neurons
        timestamp = time.time()
        hebbian_learning.activate_neurons(request.neuron_ids, timestamp)

        # Update weights
        hebbian_learning.update_weights()

        # Get stats
        stats = hebbian_learning.get_statistics()

        return HebbianActivationResponse(
            success=True,
            activated_neurons=request.neuron_ids,
            connections_formed=stats["connections"],
            avg_weight=stats["avg_weight"],
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Hebbian activation failed: {str(e)}"
        )


@router.post("/synaptic-pruning/execute", tags=["LAB_042-043"])
async def execute_synaptic_pruning():
    """
    LAB_042/043: Execute synaptic pruning and neurogenesis

    Huttenlocher (1979) pruning, Altman & Das (1965) neurogenesis
    - Prunes weak neurons
    - Generates new neurons to maintain count
    """
    try:
        # Age neurons
        synaptic_pruning.age_neurons()

        # Prune
        pruned = synaptic_pruning.prune_weak_neurons()

        # Neurogenesis
        synaptic_pruning.homeostatic_regulation()

        # Stats
        stats = synaptic_pruning.get_statistics()

        return {
            "success": True,
            "pruned_count": len(pruned),
            "total_neurons": stats["total_neurons"],
            "avg_strength": stats["avg_strength"],
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Synaptic pruning failed: {str(e)}"
        )


# ============================================
# FASE 8: Homeostasis Endpoints
# ============================================

@router.post("/homeostasis/update", response_model=HomeostasisUpdateResponse, tags=["LAB_044-050"])
async def update_homeostasis(request: HomeostasisUpdateRequest):
    """
    LAB_044-050: Update all homeostatic systems

    Systems:
    - LAB_044: Circadian rhythms (24h cycle)
    - LAB_045: Energy management
    - LAB_046: Stress regulation
    - LAB_047: Allostatic load (cumulative stress)
    - LAB_048: Homeostatic plasticity
    - LAB_049: Sleep pressure
    - LAB_050: Recovery mechanisms
    """
    try:
        homeostasis.update(dt=request.dt)
        state = homeostasis.get_state()

        return HomeostasisUpdateResponse(
            success=True,
            circadian_phase=state.circadian_phase,
            energy_level=state.energy_level,
            stress_level=state.stress_level,
            allostatic_load=state.allostatic_load,
            sleep_pressure=state.sleep_pressure,
            recovery_rate=state.recovery_rate,
            timestamp=datetime.now()
        )

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Homeostasis update failed: {str(e)}"
        )


@router.post("/homeostasis/stressor", tags=["LAB_046"])
async def add_stressor(request: StressorRequest):
    """
    LAB_046: Add stressor to system

    Increases stress level, may accumulate allostatic load if sustained
    """
    try:
        homeostasis.add_stressor(request.intensity)
        state = homeostasis.get_state()

        return {
            "success": True,
            "new_stress_level": state.stress_level,
            "allostatic_load": state.allostatic_load,
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to add stressor: {str(e)}"
        )


@router.post("/homeostasis/sleep", tags=["LAB_049"])
async def sleep_period(request: SleepRequest):
    """
    LAB_049: Execute sleep period

    Releases sleep pressure, recovers energy, reduces stress
    """
    try:
        homeostasis.sleep(request.duration)
        state = homeostasis.get_state()

        return {
            "success": True,
            "energy_level": state.energy_level,
            "stress_level": state.stress_level,
            "sleep_pressure": state.sleep_pressure,
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Sleep period failed: {str(e)}"
        )


@router.get("/homeostasis/stats", tags=["LAB_044-050"])
async def get_homeostasis_stats():
    """
    Get comprehensive homeostasis statistics
    """
    try:
        stats = homeostasis.get_statistics()

        return {
            "success": True,
            **stats,
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get stats: {str(e)}"
        )


# ============================================
# Summary Endpoint
# ============================================

@router.get("/summary", tags=["Summary"])
async def get_all_labs_summary():
    """
    Get summary of all 50 LABS status

    Returns operational status and key metrics for all LABS
    """
    try:
        return {
            "success": True,
            "total_labs": 50,
            "active_labs": 50,
            "fases": {
                "FASE_5_CREATIVITY": {
                    "labs": ["029", "030", "031", "032", "033"],
                    "status": "active",
                    "systems": ["divergent_thinking", "conceptual_blending", "insight", "analogy", "metaphor"]
                },
                "FASE_6_LEARNING": {
                    "labs": ["034", "035", "036", "037", "038"],
                    "status": "active",
                    "systems": ["transfer_learning", "reward_prediction", "meta_learning", "curiosity", "intrinsic_motivation"]
                },
                "FASE_7_PLASTICITY": {
                    "labs": ["039", "040", "041", "042", "043"],
                    "status": "active",
                    "systems": ["ltp_ltd", "hebbian_learning", "synaptic_pruning_neurogenesis"]
                },
                "FASE_8_HOMEOSTASIS": {
                    "labs": ["044", "045", "046", "047", "048", "049", "050"],
                    "status": "active",
                    "systems": ["homeostasis_unified"]
                }
            },
            "integration_complete": True,
            "api_version": "2.0.0",
            "timestamp": datetime.now()
        }

    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get summary: {str(e)}"
        )
